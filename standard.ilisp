;; IdeLISP Standard library

;; Atoms
(def '(nil) 0)
(def '(true) 1)
(def '(false) 0)

;; Function

; Unpack list to function
(defn '(unpack) '(f items)
  '(eval (join (list f) items)))

; Unapply list to function
(defn '(pack) '(f &rest items)
  '(f items))

; Curry/uncurry aliases
(def '(curry) unpack)
(def '(uncurry) pack)

; Call fns in sequence
(defn '(do) '(&rest items)
  '(if (== items nil)
    '(nil)
    '(last items)))

; Flip arguments
(defn '(flip) '(f x y)
  '(f y x))

; Compose function
(defn '(comp) '(f g fs)
  '(f (g fs)))

;; List functions

; Retrive unwrapped first, second and third element in list
(defn '(fst) '(items)
  '(eval (head items)))

(defn '(snd) '(items)
  '(eval (head (tail items))))

(defn '(trd) '(items)
  '(eval (head (tail (tail items)))))

; Quoted list length
(defn '(len) '(items)
  '(if (not items)
    '(0)
    '(+ 1 (len (tail items)))))

; Retrive element at list index
(defn '(nth) '(n items)
  '(if (== n 0)
    '(fst items)
    '(nth (- n 1) (tail items))))

; Retrive last element of list
(defn '(last) '(items)
  '(nth (- (len items) 1) items))

; Retrive elements from list
(defn '(take) '(num items)
  '(if (== num 0)
    '('())
    '(join
      (head items)
      (take
        (- num 1)
        (tail items)))))

; Drop elements from list
(defn '(drop) '(num items)
  '(if (== num 0)
    '(items)
    '(drop (- num 1) (tail items))))

; Split list after num
(defn '(split) '(num items)
  '(list (take num items) (drop num items)))

; Check if element is in list
(defn '(elem) '(needle items)
  '(if (== items '())
    '(false)
    '(if (== needle (fst items))
      '(true)
      '(elem needle (tail items)))))

; Apply function on every element in list
(defn '(map) '(f items)
  '(if (== items '())
    '('())
    '(join
      (list (f (fst items)))
      (map f (tail items)))))

; Filter list by predicate
(defn '(filter) '(p items)
  '(if (== items '())
    '('())
    '(join
       (if (p (fst items))
         '(head items)
         '('()))
       (filter p (tail items)))))

; Fold value left to right
(defn '(foldl) '(f acc items)
  '(if (== items '())
    '(acc)
    '(foldl f (f acc (fst items)) (tail items))))

(defn '(zip) '(x y)
  '(if (or (not x) (not y))
    '('())
    '(join
      (list
        (join
          (head x)
          (head y)))
        (zip
          (tail x)
          (tail y)))))

;; Conditional

(defn '(select) '(&rest cs)
  '(if (not cs)
    '(error "No cases found")
    '(if (fst (fst cs))
      '(snd (fst cs))
      '(if (== (- (len cs) 1) 0)
        '(error "No matching case found")
        '(unpack select (tail cs))))))

(defn '(case) '(needle &rest cs)
  '(if (not cs)
    '(error "No case found")
    '(if (== needle (fst (fst cs)))
      '(snd (fst cs))
      '(if (== (- (len cs) 1) 0)
        '(error "No matching case found")
        '(unpack case (join (list needle) (tail cs)))))))

;; Numerical

; Get sum of args
(defn '(sum) '(items) '(foldl + 0 items))

; Get products of args
(defn '(product) '(items) '(foldl * 1 items))

;; String

; Construct string from list
(defn '(str-join) '(values)
  '(foldl concat "" values))

;; Misc

; Fibonacci
(defn '(fib) '(x)
  '(select
    '((== x 0) 0)
    '((== x 1) 1)
    '(1 (+ (fib (- x 1)) (fib (- x 2))))))
